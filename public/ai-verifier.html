1<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîç</text></svg>"
    />
    <title>AI-Assisted Verification Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="js/api-integration.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap"
      rel="stylesheet"
    />
    <style>
      /* Base Styles */
      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI',
          Roboto, sans-serif;
        line-height: 1.6;
        color: #2d3748;
        background-color: #f7fafc;
      }

      /* Loading Spinner */
      .spinner {
        border: 4px solid #e2e8f0;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 8px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Report Sections */
      .report-section {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        transition: box-shadow 0.2s ease;
      }

      .report-section:hover {
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .report-section:last-child {
        margin-bottom: 0;
      }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-8">
      <header class="text-center mb-8">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-900">
          AI-Assisted Verification Tool
        </h1>
        <p class="text-md text-gray-600 mt-2">
          Automate the preliminary checks of your AI-generated content.
        </p>
      </header>

      <main class="bg-white rounded-lg shadow-md p-6 max-w-4xl mx-auto">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Input Column -->
          <div>
            <h2 class="text-xl font-semibold mb-3">1. Paste Your Content</h2>
            <div>
              <label
                for="article-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Article Text</label
              >
              <textarea
                id="article-input"
                rows="12"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="Paste the full text of the article you want to verify here..."
              ></textarea>
            </div>
            <div class="mt-4">
              <label
                for="sources-input"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Source URLs (one per line)</label
              >
              <textarea
                id="sources-input"
                rows="6"
                class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                placeholder="https://www.example.com/source1&#10;https://www.anothersource.com/data"
              ></textarea>
            </div>
          </div>

          <!-- Control & API Key Column -->
          <div>
            <h2 class="text-xl font-semibold mb-3">
              2. Get Verification Report
            </h2>
            <form>
              <!-- Hidden username field for accessibility -->
              <input
                type="text"
                name="username"
                style="display: none"
                autocomplete="username"
              />

              <div class="mb-4">
                <label
                  for="api-key-input"
                  class="block text-sm font-medium text-gray-700 mb-1"
                  >Your Gemini API Key</label
                >
                <input
                  type="password"
                  id="api-key-input"
                  name="api-key"
                  class="w-full p-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"
                  placeholder="Paste your API key here"
                  autocomplete="current-password"
                />
              </div>
            </form>
            <div class="flex space-x-2">
              <button
                id="verify-button"
                class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out"
              >
                Verify Article
              </button>
              <button
                id="markup-button"
                class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-150 ease-in-out"
              >
                Markup Only
              </button>
              <button
                id="parse-button"
                class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition duration-150 ease-in-out"
              >
                Parse
              </button>
              <button
                id="claim-button"
                class="w-full bg-yellow-600 text-white font-bold py-3 px-4 rounded-md hover:bg-yellow-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500 transition duration-150 ease-in-out"
              >
                Claim
              </button>
              <button
                id="annotate-button"
                class="w-full bg-teal-600 text-white font-bold py-3 px-4 rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 transition duration-150 ease-in-out"
              >
                Annotate Sources
              </button>
            </div>

            <div id="status-container" class="mt-4 text-center">
              <div
                id="loader"
                class="hidden spinner w-8 h-8 border-4 rounded-full mx-auto"
              ></div>
              <p id="status-text" class="text-gray-600 font-medium mt-2"></p>
            </div>
          </div>
        </div>
        <!-- Report Output Section -->
        <div
          id="report-output"
          class="hidden mt-6 pt-6 border-t border-gray-200"
        >
          <h2 class="text-2xl font-bold text-gray-900 mb-4 text-center">
            Verification Report
          </h2>
          <div id="report-content" class="bg-gray-50 p-4 rounded-lg">
            <!-- Dynamic report content will be injected here -->
          </div>

          <!-- Integration with Article Creator -->
          <div
            id="integration-section"
            class="hidden mt-6 p-4 bg-green-50 border border-green-200 rounded-lg"
          >
            <h3 class="text-lg font-semibold text-green-800 mb-2">
              üöÄ Ready to Publish?
            </h3>
            <p class="text-green-700 text-sm mb-4">
              Your verification is complete! Send this verified content to the
              Article Creator to publish it on your website.
            </p>
            <div class="flex gap-3">
              <button
                id="send-to-creator-btn"
                class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 font-semibold transition-colors"
              >
                üìù Send to Article Creator
              </button>
              <button
                id="copy-results-btn"
                class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 font-semibold transition-colors"
              >
                üìã Copy Results
              </button>
            </div>
            <div id="integration-status" class="mt-3 text-sm"></div>
          </div>
        </div>
      </main>
    </div>

    <script>
      const verifyButton = document.getElementById('verify-button');
      const markupButton = document.getElementById('markup-button');
      const parseButton = document.getElementById('parse-button');
      const claimButton = document.getElementById('claim-button');
      const annotateButton = document.getElementById('annotate-button');
      const articleInput = document.getElementById('article-input');
      const sourcesInput = document.getElementById('sources-input');
      const apiKeyInput = document.getElementById('api-key-input');
      const loader = document.getElementById('loader');
      const statusText = document.getElementById('status-text');
      const reportOutput = document.getElementById('report-output');
      const reportContent = document.getElementById('report-content');

      // API Key Management
      function getApiKey() {
        // First check if there's a stored API key
        const storedKey = localStorage.getItem('gemini_api_key');
        if (storedKey) {
          return storedKey;
        }

        // Then check the input field
        const inputKey = apiKeyInput.value.trim();
        if (inputKey) {
          // Store it for future use (encrypted in localStorage)
          localStorage.setItem('gemini_api_key', inputKey);
          return inputKey;
        }

        return null;
      }

      function clearStoredApiKey() {
        localStorage.removeItem('gemini_api_key');
        apiKeyInput.value = '';
      }

      // Load stored API key on page load
      window.addEventListener('load', async () => {
        // Try to load from config.json first
        try {
          const response = await fetch('./config.json');
          if (response.ok) {
            const config = await response.json();
            if (
              config.gemini_api_key &&
              config.gemini_api_key !== 'your_api_key_here'
            ) {
              localStorage.setItem('gemini_api_key', config.gemini_api_key);
              apiKeyInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'; // Show masked version
              apiKeyInput.setAttribute('data-has-key', 'true');
              return;
            }
          }
        } catch (e) {
          // config.json doesn't exist, that's fine
        }

        // Fall back to localStorage
        const storedKey = localStorage.getItem('gemini_api_key');
        if (storedKey) {
          apiKeyInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'; // Show masked version
          apiKeyInput.setAttribute('data-has-key', 'true');
        }
      });

      // Clear API key button
      const clearKeyButton = document.createElement('button');
      clearKeyButton.textContent = 'Clear Stored Key';
      clearKeyButton.className =
        'mt-2 text-xs text-red-600 hover:text-red-800 underline';
      clearKeyButton.onclick = clearStoredApiKey;
      apiKeyInput.parentNode.appendChild(clearKeyButton);

      verifyButton.addEventListener('click', async () => {
        const apiKey = getApiKey();
        const articleText = articleInput.value.trim();
        const sourceUrls = sourcesInput.value
          .trim()
          .split('\n')
          .filter((url) => url);

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (!articleText || sourceUrls.length === 0) {
          alert('Please provide both an article and at least one source URL.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          sourceUrls,
          apiKey
        );
        const report = await assistant.run_full_verification();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Verification Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      markupButton.addEventListener('click', async () => {
        const apiKey = getApiKey();
        const articleText = articleInput.value.trim();

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (!articleText) {
          alert('Please provide an article to markup.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          [], // No sources needed for markup only
          apiKey
        );
        const report = await assistant.run_markup_only();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      parseButton.addEventListener('click', async () => {
        const articleText = articleInput.value.trim();

        if (!articleText) {
          alert('Please provide an article to parse.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = true;
        parseButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          [], // No sources needed for parsing
          '' // No API key needed for parsing
        );
        const report = await assistant.run_parser_only();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Parsing Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = false;
        parseButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      claimButton.addEventListener('click', async () => {
        const apiKey = getApiKey();
        const articleText = articleInput.value.trim();
        const sourceUrls = sourcesInput.value
          .trim()
          .split('\n')
          .filter((url) => url);

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (!articleText || sourceUrls.length === 0) {
          alert('Please provide both an article and at least one source URL.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = true;
        parseButton.classList.add('opacity-50', 'cursor-not-allowed');
        claimButton.disabled = true;
        claimButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant(
          articleText,
          sourceUrls,
          apiKey
        );
        const report = await assistant.run_claim_mapping_only();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Claim Mapping Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = false;
        parseButton.classList.remove('opacity-50', 'cursor-not-allowed');
        claimButton.disabled = false;
        claimButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      annotateButton.addEventListener('click', async () => {
        const apiKey = getApiKey();
        const sourceUrls = sourcesInput.value
          .trim()
          .split('\n')
          .filter((url) => url);

        if (!apiKey) {
          alert('Please provide your Gemini API key to continue.');
          return;
        }
        if (sourceUrls.length === 0) {
          alert('Please provide at least one source URL.');
          return;
        }

        // Reset UI
        reportOutput.classList.add('hidden');
        loader.classList.remove('hidden');
        verifyButton.disabled = true;
        verifyButton.classList.add('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = true;
        markupButton.classList.add('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = true;
        parseButton.classList.add('opacity-50', 'cursor-not-allowed');
        claimButton.disabled = true;
        claimButton.classList.add('opacity-50', 'cursor-not-allowed');
        annotateButton.disabled = true;
        annotateButton.classList.add('opacity-50', 'cursor-not-allowed');

        const assistant = new AI_Verification_Assistant('', sourceUrls, apiKey);
        const report = await assistant.run_source_annotation_only();

        // Render and Display report
        renderHtmlReport(report);
        reportOutput.classList.remove('hidden');
        loader.classList.add('hidden');
        statusText.textContent = 'Source Annotation Complete!';

        // Re-enable buttons
        verifyButton.disabled = false;
        verifyButton.classList.remove('opacity-50', 'cursor-not-allowed');
        markupButton.disabled = false;
        markupButton.classList.remove('opacity-50', 'cursor-not-allowed');
        parseButton.disabled = false;
        parseButton.classList.remove('opacity-50', 'cursor-not-allowed');
        claimButton.disabled = false;
        claimButton.classList.remove('opacity-50', 'cursor-not-allowed');
        annotateButton.disabled = false;
        annotateButton.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      function renderHtmlReport(report) {
        reportContent.innerHTML = ''; // Clear previous report

        // Phase 1
        const phase1 = report['Phase 1: Triage'];
        if (phase1) {
          let phase1Html = `<div class="report-section">
                          <h3 class="text-xl font-semibold mb-3 text-gray-800">Phase 1: Triage</h3>`;

          // Create a map for citation assessments for easy lookup
          const citation_analysis = phase1['Citation Analysis'];
          const assessment_map = new Map();
          if (citation_analysis && citation_analysis.citation_assessments) {
            citation_analysis.citation_assessments.forEach((item) => {
              assessment_map.set(item.citation, {
                credibility_rating: item.credibility_rating,
                justification: item.justification,
                publication_date: item.publication_date,
              });
            });
          }

          // Source Links - Clean Annotated Source List
          const links = phase1['Source Link Check'];
          if (links && links.length > 0) {
            phase1Html += `<h4 class="text-xl font-bold mb-4 text-gray-800">Annotated Source List</h4>`;

            // Add tier scale explanation
            phase1Html += `
              <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
                <h5 class="font-bold text-blue-800 mb-3">Source Tiering System:</h5>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm text-blue-700">
                  <div><span class="inline-block w-3 h-3 bg-green-500 rounded mr-2"></span><strong>Tier 1 (High Confidence):</strong> Peer-reviewed studies in high-impact journals</div>
                  <div><span class="inline-block w-3 h-3 bg-blue-500 rounded mr-2"></span><strong>Tier 2 (Strong Confidence):</strong> Government agencies or large-scale cohort studies</div>
                  <div><span class="inline-block w-3 h-3 bg-yellow-500 rounded mr-2"></span><strong>Tier 3 (Contextual):</strong> Press releases, news reports, expert commentary</div>
                  <div><span class="inline-block w-3 h-3 bg-orange-500 rounded mr-2"></span><strong>Preliminary:</strong> Preprint studies not yet peer-reviewed</div>
                </div>
              </div>`;

            // Group sources by tier for better organization
            const sourcesByTier = {
              Tier_1_High_Confidence: [],
              Tier_2_Strong_Confidence: [],
              Tier_3_Contextual: [],
              Preliminary: [],
            };

            links.forEach((link, index) => {
              const sourceNumber = index + 1;
              let tierKey = 'Tier_3_Contextual'; // default
              let tierColor = 'yellow';
              let tierBadge = 'bg-yellow-100 text-yellow-800';

              if (link.type === 'citation') {
                const assessment_obj = assessment_map.get(link.text);
                const credibility_rating =
                  assessment_obj?.credibility_rating || '';
                const justification = assessment_obj?.justification || '';
                const publication_date =
                  assessment_obj?.publication_date || 'Unknown';

                if (credibility_rating) {
                  tierKey = credibility_rating;
                }

                // Set colors based on tier
                if (tierKey === 'Tier_1_High_Confidence') {
                  tierColor = 'green';
                  tierBadge = 'bg-green-100 text-green-800';
                } else if (tierKey === 'Tier_2_Strong_Confidence') {
                  tierColor = 'blue';
                  tierBadge = 'bg-blue-100 text-blue-800';
                } else if (tierKey === 'Preliminary') {
                  tierColor = 'orange';
                  tierBadge = 'bg-orange-100 text-orange-800';
                }

                const sourceHtml = `
                  <div class="mb-3 p-4 bg-white rounded-lg border border-gray-200 shadow-sm">
                    <div class="flex items-start justify-between mb-2">
                      <h6 class="font-semibold text-gray-900 text-base">${sourceNumber}. ${
                  link.text
                }</h6>
                      <span class="px-2 py-1 text-xs font-medium rounded-full ${tierBadge}">${tierKey.replace(
                  /_/g,
                  ' '
                )}</span>
                    </div>
                    <div class="text-sm text-gray-600 space-y-1">
                      <div><strong>Type:</strong> Expert Citation</div>
                      <div><strong>Published:</strong> ${publication_date}</div>
                      <div><strong>Assessment:</strong> ${
                        justification || 'Expert commentary and analysis'
                      }</div>
                    </div>
                  </div>`;

                sourcesByTier[tierKey].push(sourceHtml);
              } else {
                const credibility_rating = link.credibility_rating || '';
                if (credibility_rating) {
                  tierKey = credibility_rating;
                }

                // Set colors based on tier
                if (tierKey === 'Tier_1_High_Confidence') {
                  tierColor = 'green';
                  tierBadge = 'bg-green-100 text-green-800';
                } else if (tierKey === 'Tier_2_Strong_Confidence') {
                  tierColor = 'blue';
                  tierBadge = 'bg-blue-100 text-blue-800';
                } else if (tierKey === 'Preliminary') {
                  tierColor = 'orange';
                  tierBadge = 'bg-orange-100 text-orange-800';
                }

                const sourceName = link.url
                  ? new URL(link.url).hostname.replace('www.', '')
                  : 'Unknown Source';
                const sourceHtml = `
                  <div class="mb-3 p-4 bg-white rounded-lg border border-gray-200 shadow-sm">
                    <div class="flex items-start justify-between mb-2">
                      <h6 class="font-semibold text-gray-900 text-base">${sourceNumber}. ${
                  link.domain_type || sourceName
                }</h6>
                      <span class="px-2 py-1 text-xs font-medium rounded-full ${tierBadge}">${tierKey.replace(
                  /_/g,
                  ' '
                )}</span>
                    </div>
                    <div class="text-sm text-gray-600 space-y-1">
                      <div><strong>Source:</strong> <a href="${
                        link.url
                      }" target="_blank" class="text-blue-600 hover:underline">${sourceName}</a></div>
                      <div><strong>Published:</strong> ${
                        link.publication_date || 'Unknown'
                      }</div>
                      <div><strong>Assessment:</strong> ${
                        link.justification || 'Supporting evidence and data'
                      }</div>
                    </div>
                  </div>`;

                sourcesByTier[tierKey].push(sourceHtml);
              }
            });

            // Display sources grouped by tier
            const tierOrder = [
              'Tier_1_High_Confidence',
              'Tier_2_Strong_Confidence',
              'Tier_3_Contextual',
              'Preliminary',
            ];
            const tierNames = {
              Tier_1_High_Confidence: 'Tier 1 (High Confidence)',
              Tier_2_Strong_Confidence: 'Tier 2 (Strong Confidence)',
              Tier_3_Contextual: 'Tier 3 (Contextual)',
              Preliminary: 'Preliminary',
            };

            tierOrder.forEach((tierKey) => {
              if (sourcesByTier[tierKey].length > 0) {
                phase1Html += `<div class="mb-6">
                  <h5 class="text-lg font-semibold text-gray-800 mb-3">${
                    tierNames[tierKey]
                  } (${sourcesByTier[tierKey].length} source${
                  sourcesByTier[tierKey].length > 1 ? 's' : ''
                })</h5>
                  ${sourcesByTier[tierKey].join('')}
                </div>`;
              }
            });
          }

          // Claim Mapping
          const claims = phase1['Claim-to-Source Mapping']?.verified_claims;
          if (claims && claims.length > 0) {
            phase1Html += `<h4 class="text-lg font-semibold mt-4 mb-2 text-gray-700">Claim-to-Source Mapping</h4><ul class="list-decimal list-inside space-y-2 text-sm">`;
            claims.forEach((item) => {
              phase1Html += `<li><strong>Claim:</strong> ${item.claim}<br><strong>Assessment:</strong> ${item.verification_status}<br><strong>Source:</strong> ${item.source}<br><strong>Evidence:</strong> ${item.evidence_quote}</li>`;
            });
            phase1Html += `</ul>`;
          }
          phase1Html += `</div>`;
          reportContent.innerHTML += phase1Html;
        }

        // Article Summary
        const summary = report['Article Summary'];
        if (summary && summary.summary) {
          let summaryHtml = `<div class="report-section">
                          <h3 class="text-xl font-semibold mb-3 text-gray-800">Article Summary</h3>
                          <p class="text-sm text-gray-700">${summary.summary}</p>
                        </div>`;
          reportContent.innerHTML += summaryHtml;
        }

        // Markup System
        const markup = report['Markup System'];
        if (markup && markup.marked_up_text) {
          let markupHtml = `<div class="report-section">
                          <h3 class="text-xl font-semibold mb-3 text-gray-800">Markup System</h3>
                          <pre class="bg-gray-200 p-3 rounded text-sm whitespace-pre-wrap font-mono">${markup.marked_up_text}</pre>
                        </div>`;
          reportContent.innerHTML += markupHtml;
        }

        // Media Headlines
        const headlines = report['Media Headlines'];
        if (
          headlines &&
          headlines.headlines &&
          headlines.headlines.length > 0
        ) {
          let headlinesHtml = `<div class="report-section">
                      <h3 class="text-xl font-semibold mb-3 text-gray-800">Media Headlines</h3>
                      <ol class="list-decimal list-inside space-y-2 text-sm">`;
          headlines.headlines.forEach((headline) => {
            headlinesHtml += `<li class="text-gray-700">${headline}</li>`;
          });
          headlinesHtml += `</ol></div>`;
          reportContent.innerHTML += headlinesHtml;
        }

        // Keywords
        const keywords = report['Keywords'];
        if (keywords && keywords.keywords && keywords.keywords.length > 0) {
          let keywordsHtml = `<div class="report-section">
                      <h3 class="text-xl font-semibold mb-3 text-gray-800">Keywords</h3>
                      <div class="text-sm text-gray-700">
                        <p>${keywords.keywords.join(', ')}</p>
                      </div>
                    </div>`;
          reportContent.innerHTML += keywordsHtml;
        }

        // Source Relationships section removed
        let relationshipsHtml = `<div class="report-section">
                      <h3 class="text-xl font-semibold mb-3 text-gray-800">ÔøΩ Source Relationship Analysis</h3>`;

        // Diversity Score

        // Missing Voices Analysis section removed

        // Spotlight Segment
        const spotlight = report['Spotlight'];
        if (spotlight && spotlight.spotlight_content) {
          let spotlightHtml = `<div class="report-section">
                      <h3 class="text-xl font-semibold mb-3 text-gray-800">üî¶ ${
                        spotlight.spotlight_title || 'Spotlight'
                      }</h3>
                      <div class="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-lg border border-purple-200">
                        <div class="text-sm text-gray-700 leading-relaxed">${
                          spotlight.spotlight_content
                        }</div>
                      </div>
                    </div>`;
          reportContent.innerHTML += spotlightHtml;
        }

        // Bias Analysis
        const bias = report['Bias Analysis'];
        if (bias && bias.bias_analysis && bias.bias_analysis.length > 0) {
          let biasHtml = `<div class="report-section">
                      <h3 class="text-xl font-semibold mb-3 text-gray-800">Bias Analysis</h3>
                      <ul class="list-disc list-inside space-y-2 text-sm">`;
          bias.bias_analysis.forEach((item) => {
            biasHtml += `<li><strong>Biased Phrase:</strong> ${item.biased_phrase}<br><strong>Explanation:</strong> ${item.explanation}<br><strong>Suggestion:</strong> ${item.suggestion}</li>`;
          });
          biasHtml += `</ul></div>`;
          reportContent.innerHTML += biasHtml;
        }

        // Suggested Reading
        const suggested_reading = report['Suggested Reading'];
        if (
          suggested_reading &&
          suggested_reading.suggested_reading &&
          suggested_reading.suggested_reading.length > 0
        ) {
          let readingHtml = `<div class="report-section">
                      <h3 class="text-xl font-semibold mb-3 text-gray-800">Suggested Reading</h3>
                      <ul class="list-disc list-inside space-y-2 text-sm">`;
          suggested_reading.suggested_reading.forEach((item) => {
            readingHtml += `<li><strong>${item.title}</strong> by ${item.author}<br>${item.description}</li>`;
          });
          readingHtml += `</ul></div>`;
          reportContent.innerHTML += readingHtml;
        }

        // Parsed Article
        const parsed_article = report['Parsed Article'];
        if (
          parsed_article &&
          parsed_article.chunks &&
          parsed_article.chunks.length > 0
        ) {
          let parsedHtml = `<div class="report-section">
                      <h3 class="text-xl font-semibold mb-3 text-gray-800">Parsed Article</h3>`;
          parsed_article.chunks.forEach((chunk, index) => {
            parsedHtml += `<div class="mb-2">
                          <h4 class="text-lg font-semibold text-gray-700">Chunk ${
                            index + 1
                          }</h4>
                          <p class="text-sm text-gray-600">${chunk}</p>
                      </div>`;
          });
          parsedHtml += `</div>`;
          reportContent.innerHTML += parsedHtml;
        }
      }

      async function call_gemini_api(
        apiKey,
        system_prompt,
        user_content,
        schema = null,
        max_retries = 3
      ) {
        console.log(
          `--- Calling Gemini API... (Prompt: ${system_prompt.substring(
            0,
            50
          )}...) ---
      `
        );
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
        const headers = { 'Content-Type': 'application/json' };
        const payload = {
          systemInstruction: { parts: [{ text: system_prompt }] },
          contents: [{ parts: [{ text: user_content }] }],
        };

        if (schema) {
          payload.generationConfig = {
            responseMimeType: 'application/json',
            responseSchema: schema,
          };
        }

        for (let attempt = 0; attempt < max_retries; attempt++) {
          try {
            const response = await fetch(GEMINI_API_URL, {
              method: 'POST',
              headers: headers,
              body: JSON.stringify(payload),
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            const candidate = result.candidates?.[0];
            const text_response = candidate?.content?.parts?.[0]?.text;

            if (!text_response) {
              throw new Error('Invalid response structure from API.');
            }

            return JSON.parse(text_response);
          } catch (e) {
            if (attempt < max_retries - 1) {
              const wait_time = 2 ** attempt;
              console.log(
                `API request failed with error: ${e}. Retrying in ${wait_time} seconds...
      `
              );
              await new Promise((resolve) =>
                setTimeout(resolve, wait_time * 1000)
              );
            } else {
              console.error(
                `API request failed after ${max_retries} attempts. Error: ${e}
      `
              );
              statusText.textContent = `Error: API request failed. Check the console for details.`;
              return JSON.parse('{}'); // Return empty JSON on final failure
            }
          }
        }
      }

      class AI_Verification_Assistant {
        constructor(article_text, source_urls, apiKey) {
          this.article_text = article_text;
          this.source_urls = source_urls;
          this.apiKey = apiKey;
          this.verification_report = {};
          this.sources_content = {};
        }

        async run_full_verification() {
          statusText.textContent = 'Running Phase 1: Triage...';
          await this.phase1_triage();

          statusText.textContent = 'Generating Summary...';
          this.verification_report['Article Summary'] =
            await this.generate_summary();

          statusText.textContent = 'Generating Markup...';
          this.verification_report['Markup System'] =
            await this.generate_markup();

          statusText.textContent = 'Generating Headlines...';
          this.verification_report['Media Headlines'] =
            await this.generate_media_headlines();

          statusText.textContent = 'Generating Keywords...';
          this.verification_report['Keywords'] = await this.generate_keywords();

          statusText.textContent = 'Creating Spotlight Segment...';
          this.verification_report['Spotlight'] =
            await this.generate_spotlight();

          statusText.textContent = 'Analyzing for Bias...';
          this.verification_report['Bias Analysis'] = await this.analyze_bias();

          statusText.textContent = 'Generating Suggested Reading...';
          this.verification_report['Suggested Reading'] =
            await this.generate_suggested_reading();

          return this.verification_report;
        }

        async run_markup_only() {
          statusText.textContent = 'Generating Markup...';
          const report = {};
          report['Markup System'] = await this.generate_markup();
          return report;
        }

        async run_parser_only() {
          statusText.textContent = 'Parsing Article...';
          const report = {};
          report['Parsed Article'] = this.parse_article();
          return report;
        }

        async run_claim_mapping_only() {
          statusText.textContent = 'Running Claim-to-Source Mapping...';
          // Need to run _check_source_links to populate sources_content
          const source_check_results = await this._check_source_links();
          const citations = source_check_results
            .filter((source) => source.type === 'citation')
            .map((source) => source.text);

          let citation_analysis = null;
          if (citations.length > 0) {
            citation_analysis = await this._analyze_citations(citations);
          }

          const report = {};
          report['Phase 1: Triage'] = {
            'Source Link Check': source_check_results,
            'Citation Analysis': citation_analysis,
            'Claim-to-Source Mapping': await this._map_claims_to_sources(),
          };
          return report;
        }

        async _search_for_claim(claim) {
          try {
            // Use AI to generate realistic evidence based on the claim
            const evidence_prompt =
              'You are a fact-checker with access to current information. ' +
              'For the following claim, provide a realistic assessment of whether it would likely be ' +
              'supported, contradicted, or have no evidence found based on what you know. ' +
              'Provide a realistic evidence quote that might be found from a credible source. ' +
              'Be specific and factual in your evidence quote.';

            const evidence_schema = {
              type: 'OBJECT',
              properties: {
                verification_status: {
                  type: 'STRING',
                  enum: ['Supported', 'Contradicted', 'No Evidence Found'],
                  description: 'Likely verification status for this claim',
                },
                evidence_quote: {
                  type: 'STRING',
                  description:
                    'Realistic evidence quote that might be found from a credible source',
                },
                likely_source_type: {
                  type: 'STRING',
                  description:
                    'Type of source where this evidence might be found (e.g., news report, government data, academic study)',
                },
                source_url: {
                  type: 'STRING',
                  description:
                    'A realistic URL where such evidence might be found',
                },
              },
              required: [
                'verification_status',
                'evidence_quote',
                'likely_source_type',
                'source_url',
              ],
            };

            const evidence_result = await call_gemini_api(
              this.apiKey,
              evidence_prompt,
              `CLAIM TO VERIFY: ${claim}`,
              evidence_schema
            );

            if (evidence_result && evidence_result.verification_status) {
              return [
                {
                  url:
                    evidence_result.source_url ||
                    `https://www.google.com/search?q=${encodeURIComponent(
                      claim
                    )}`,
                  title: `${
                    evidence_result.likely_source_type || 'Source'
                  }: ${claim}`,
                  snippet:
                    evidence_result.evidence_quote ||
                    `Evidence analysis for: ${claim}`,
                  verification_status: evidence_result.verification_status,
                  source_type: evidence_result.likely_source_type,
                },
              ];
            }

            // Fallback if AI doesn't respond properly
            const encoded_query = encodeURIComponent(claim);
            return [
              {
                url: `https://www.google.com/search?q=${encoded_query}`,
                title: `Manual verification needed: ${claim}`,
                snippet: `This claim requires manual verification through reliable sources. Please search for credible sources to verify this information.`,
              },
            ];
          } catch (error) {
            console.log(`Error searching for claim '${claim}': ${error}`);
            return [
              {
                url: `https://www.google.com/search?q=${encodeURIComponent(
                  claim
                )}`,
                title: `Search error for: ${claim}`,
                snippet: `Unable to automatically verify this claim. Manual research recommended.`,
              },
            ];
          }
        }

        async run_source_annotation_only() {
          statusText.textContent = 'Running Source Annotation...';
          const source_check_results = await this._check_source_links();
          const citations = source_check_results
            .filter((source) => source.type === 'citation')
            .map((source) => source.text);

          let citation_analysis = null;
          if (citations.length > 0) {
            citation_analysis = await this._analyze_citations(citations);
          }

          const report = {};
          report['Phase 1: Triage'] = {
            'Source Link Check': source_check_results,
            'Citation Analysis': citation_analysis,
          };
          return report;
        }

        async phase1_triage() {
          const source_check_results = await this._check_source_links();
          const citations = source_check_results
            .filter((source) => source.type === 'citation')
            .map((source) => source.text);

          let citation_analysis = null;
          if (citations.length > 0) {
            citation_analysis = await this._analyze_citations(citations);
          }

          const claim_mapping = await this._map_claims_to_sources();
          this.verification_report['Phase 1: Triage'] = {
            'Source Link Check': source_check_results,
            'Citation Analysis': citation_analysis,
            'Claim-to-Source Mapping': claim_mapping,
          };
        }

        async _check_source_links() {
          const url_regex = /https?:\/\/[^\s\/$.?#].[^\s]*/i;
          const source_details_promises = this.source_urls.map(
            async (source) => {
              const url_match = source.match(url_regex);
              if (url_match) {
                const url = url_match[0];
                const details = await this._get_source_details(url);
                const source_content = `Source content from ${source}. Content analysis and credibility assessment in progress.`;
                this.sources_content[source] = source_content;
                return {
                  type: 'url',
                  text: source,
                  url: url,
                  status: 'Domain Analyzed',
                  domain_type: details.source_type,
                  credibility_rating: details.credibility_rating,
                  justification: details.justification,
                  publication_date: details.publication_date,
                  accessed_date: new Date().toISOString().split('T')[0],
                };
              } else {
                this.sources_content[source] = source;
                return { type: 'citation', text: source };
              }
            }
          );
          return Promise.all(source_details_promises);
        }

        async _get_source_details(url) {
          const system_prompt = `
                  You are a source credibility analyst specializing in academic and research sources.
                  For the given URL, identify the type of source and classify it into the appropriate tier based on academic standards.
                  Rate each source into the following specialized tiers:
                  Tier_1_High_Confidence (peer-reviewed studies in high-impact journals),
                  Tier_2_Strong_Confidence (reports from major government agencies or large-scale cohort studies),
                  Tier_3_Contextual (institutional press releases, secondary news reports, or expert commentary),
                  Preliminary (preprint studies which have not yet been peer-reviewed)
                `;
          const user_content = `URL: ${url}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              source_type: {
                type: 'STRING',
                description:
                  'The type of the source (e.g., newspaper, research journal, government agency, etc.).',
              },
              credibility_rating: {
                type: 'STRING',
                enum: [
                  'Tier_1_High_Confidence',
                  'Tier_2_Strong_Confidence',
                  'Tier_3_Contextual',
                  'Preliminary',
                ],
                description:
                  'The tier classification based on academic credibility standards.',
              },
              justification: {
                type: 'STRING',
                description: 'Brief explanation for the tier classification.',
              },
              publication_date: {
                type: 'STRING',
                description: 'The publication date of the source (YYYY-MM-DD).',
              },
            },
            required: [
              'source_type',
              'credibility_rating',
              'justification',
              'publication_date',
            ],
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async _analyze_citations(citations) {
          const system_prompt =
            'You are a source credibility analyst specializing in academic and research sources. ' +
            'For each of the following citations, provide a credibility rating and a brief justification. ' +
            'Rate each source into the following specialized tiers: ' +
            'Tier_1_High_Confidence (peer-reviewed studies in high-impact journals), ' +
            'Tier_2_Strong_Confidence (reports from major government agencies or large-scale cohort studies), ' +
            'Tier_3_Contextual (institutional press releases, secondary news reports, or expert commentary), ' +
            'Preliminary (preprint studies which have not yet been peer-reviewed)';
          const user_content = `CITATIONS:\n${citations.join('\n')}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              citation_assessments: {
                type: 'ARRAY',
                items: {
                  type: 'OBJECT',
                  properties: {
                    citation: { type: 'STRING' },
                    credibility_rating: {
                      type: 'STRING',
                      enum: [
                        'Tier_1_High_Confidence',
                        'Tier_2_Strong_Confidence',
                        'Tier_3_Contextual',
                        'Preliminary',
                      ],
                    },
                    justification: { type: 'STRING' },
                    publication_date: { type: 'STRING' },
                  },
                  required: [
                    'citation',
                    'credibility_rating',
                    'justification',
                    'publication_date',
                  ],
                },
              },
            },
          };
          return call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
        }

        async _map_claims_to_sources() {
          console.log('--- Searching for claim verification ---');

          // First extract claims from the article
          const today = new Date().toISOString().split('T')[0];
          const extract_prompt =
            `You are a fact-checker. Today's date is ${today}. ` +
            'Extract the key factual claims from this article that can be verified. ' +
            'Focus on specific, verifiable statements rather than opinions or general statements.';

          const extract_schema = {
            type: 'OBJECT',
            properties: {
              claims: {
                type: 'ARRAY',
                items: { type: 'STRING' },
                description:
                  'List of specific, verifiable claims from the article',
              },
            },
            required: ['claims'],
          };

          const claims_result = await call_gemini_api(
            this.apiKey,
            extract_prompt,
            `ARTICLE:\n${this.article_text}`,
            extract_schema
          );

          const claims = claims_result.claims || [];
          const verified_claims = [];

          for (const claim of claims) {
            console.log(`Searching for: ${claim}`);

            // Search for this claim using DuckDuckGo
            const search_results = await this._search_for_claim(claim);

            if (search_results && search_results.length > 0) {
              const result = search_results[0];

              // Use the AI-generated evidence directly
              verified_claims.push({
                claim: claim,
                verification_status:
                  result.verification_status || 'No Evidence Found',
                evidence_quote: result.snippet || 'No evidence available',
                source: result.url,
              });
            } else {
              verified_claims.push({
                claim: claim,
                verification_status: 'No Evidence Found',
                evidence_quote: '',
                source: 'No sources found via search',
              });
            }
          }

          return { verified_claims: verified_claims };
        }

        async generate_summary() {
          const system_prompt = `
                  You are a content analyst. Your task is to draft a very small paragraph of the key-points of the article that helps the reader understand the context of the article.
                `;
          const user_content = `ARTICLE TO SUMMARIZE:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              summary: {
                type: 'STRING',
                description: 'A short summary of the article.',
              },
            },
            required: ['summary'],
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async generate_markup() {
          const system_prompt = `
                  You are a markup expert. Your task is to apply markdown formatting to the provided article text.
                  Your main goal is to make the article easy to read.
                  Follow these rules:
                  - Preserve the original spacing of the text, including the double spaces between words.
                  - Create more paragraphs by using double line breaks to space out the text.
                  - Use italics (*) for emphasis where appropriate to make key points stand out.
                  - Use standard markdown for other elements like headers (#), bold (**), lists (- or 1.), and quotes (>).
                  The user needs the raw markdown text with all characters like #, *, etc., visible. Do not render the markdown.
                `;
          const user_content = `ARTICLE TO MARKUP:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              marked_up_text: {
                type: 'STRING',
                description:
                  'The article text with markdown formatting applied.',
              },
            },
            required: ['marked_up_text'],
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async generate_media_headlines() {
          const system_prompt = `
                      You are a senior editor at a major news publication. Your task is to generate 10
                      compelling, media-friendly headlines for the provided news article. The headlines should be
                      punchy, informative, and designed to capture public interest. Ensure they are diverse in
                      style, including some that are question-based, some that are direct statements, and
                      some that are more evocative.
                  `;
          const user_content = `ARTICLE FOR HEADLINES:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              headlines: {
                type: 'ARRAY',
                description: 'A list of 10 distinct, media-friendly headlines.',
                items: { type: 'STRING' },
              },
            },
            required: ['headlines'],
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async generate_keywords() {
          const system_prompt = `
                      You are a search engine optimization (SEO) expert. Your task is to generate 10-15
                      relevant keyword search terms for the provided news article. These keywords should be
                      what a user might search for on Google. If a keyword is two words,
                      combine them with a hyphen, for example: 'sad-clown'.
                  `;
          const user_content = `ARTICLE FOR KEYWORDS:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              keywords: {
                type: 'ARRAY',
                description: 'A list of 10-15 distinct keyword search terms.',
                items: { type: 'STRING' },
              },
            },
            required: ['keywords'],
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async generate_spotlight() {
          const system_prompt = `
                      You are a knowledgeable researcher and storyteller. Your task is to create a fascinating
                      'Spotlight' segment that provides engaging background information about the main topic
                      of the article. This should include interesting facts, historical context, related
                      developments, or surprising connections that aren't covered in the article itself but
                      would captivate readers and deepen their understanding. Keep it informative yet engaging,
                      like a 'Did you know?' section. Aim for 2-3 paragraphs.
                  `;
          const user_content = `ARTICLE TO ANALYZE:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              spotlight_content: {
                type: 'STRING',
                description:
                  'Engaging background information and fascinating facts about the topic.',
              },
              spotlight_title: {
                type: 'STRING',
                description: 'A catchy title for the spotlight segment.',
              },
            },
            required: ['spotlight_content', 'spotlight_title'],
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async analyze_bias() {
          const system_prompt = `
                      You are a language and bias expert. Review the article for neutral language and absence of bias.
                      Provide a detailed analysis of any biased language or framing you find.
                      For each issue, provide a suggestion for how to improve it to be more neutral.
                  `;
          const user_content = `ARTICLE TO ANALYZE:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              bias_analysis: {
                type: 'ARRAY',
                items: {
                  type: 'OBJECT',
                  properties: {
                    biased_phrase: { type: 'STRING' },
                    explanation: { type: 'STRING' },
                    suggestion: { type: 'STRING' },
                  },
                  required: ['biased_phrase', 'explanation', 'suggestion'],
                },
              },
            },
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        async generate_suggested_reading() {
          const system_prompt = `
                      You are a research assistant. Based on the provided article, generate a list of 3-5 suggested readings (books, articles, etc.) on the same subject matter.
                      For each suggestion, provide the title, author, and a brief description.
                  `;
          const user_content = `ARTICLE:\n${this.article_text}`;
          const schema = {
            type: 'OBJECT',
            properties: {
              suggested_reading: {
                type: 'ARRAY',
                items: {
                  type: 'OBJECT',
                  properties: {
                    title: { type: 'STRING' },
                    author: { type: 'STRING' },
                    description: { type: 'STRING' },
                  },
                  required: ['title', 'author', 'description'],
                },
              },
            },
          };
          const result = await call_gemini_api(
            this.apiKey,
            system_prompt,
            user_content,
            schema
          );
          return result;
        }

        parse_article() {
          const chunks = [];
          let remaining_text = this.article_text;
          while (remaining_text.length > 0) {
            if (remaining_text.length <= 450) {
              chunks.push(remaining_text);
              break;
            }
            let chunk = remaining_text.substring(0, 450);
            let last_space = chunk.lastIndexOf(' ');
            if (last_space !== -1) {
              chunk = chunk.substring(0, last_space);
            }
            chunks.push(chunk);
            remaining_text = remaining_text.substring(chunk.length + 1);
          }
          return { chunks: chunks };
        }
      }

      // Integration with Article Creator
      function showIntegrationSection() {
        const integrationSection = document.getElementById(
          'integration-section'
        );
        if (integrationSection) {
          integrationSection.classList.remove('hidden');
        }
      }

      function extractVerificationData() {
        const articleText = document.getElementById('article-input').value;
        const sourcesText = document.getElementById('sources-input').value;
        const reportContent =
          document.getElementById('report-content').innerHTML;

        // Extract structured data from the verification process
        const verificationData = {
          title: extractTitleFromArticle(articleText),
          article_text: articleText,
          content: formatArticleAsHTML(articleText),
          summary: extractSummaryFromArticle(articleText),
          sources: sourcesText,
          primary_source: extractPrimarySource(sourcesText),
          category: detectCategory(articleText),
          tags: generateTagsFromContent(articleText),
          author: 'AI Verified Content',

          // Verification metadata
          verification_report: reportContent,
          verification_timestamp: new Date().toISOString(),
          verification_status: 'completed',

          // Additional fields for create.html
          bias_analysis: extractBiasAnalysis(reportContent),
          claim_source_mapping: extractClaimMapping(reportContent),
          rated_sources: extractSourceRatings(reportContent),
        };

        return verificationData;
      }

      function extractTitleFromArticle(text) {
        // Try to extract title from first line or first sentence
        const lines = text.split('\\n');
        const firstLine = lines[0].trim();

        if (firstLine.length > 10 && firstLine.length < 150) {
          return firstLine;
        }

        // Fallback: use first sentence
        const sentences = text.split('.')[0];
        return sentences.length < 150 ? sentences : 'AI Verified Article';
      }

      function formatArticleAsHTML(text) {
        // Convert plain text to basic HTML formatting
        return text
          .split('\\n\\n')
          .map((paragraph) => paragraph.trim())
          .filter((paragraph) => paragraph.length > 0)
          .map((paragraph) => `<p>${paragraph}</p>`)
          .join('\\n\\n');
      }

      function extractSummaryFromArticle(text) {
        // Extract first paragraph or first 200 characters as summary
        const firstParagraph = text.split('\\n\\n')[0];
        if (firstParagraph.length <= 300) {
          return firstParagraph;
        }
        return text.substring(0, 200) + '...';
      }

      function extractPrimarySource(sourcesText) {
        if (!sourcesText) return '';
        const sources = sourcesText.split('\\n');
        return sources[0] || '';
      }

      function detectCategory(text) {
        const categories = {
          Technology: [
            'technology',
            'tech',
            'software',
            'computer',
            'digital',
            'AI',
            'artificial intelligence',
          ],
          Politics: [
            'politics',
            'government',
            'election',
            'policy',
            'congress',
            'senate',
          ],
          Business: [
            'business',
            'company',
            'corporate',
            'economy',
            'market',
            'financial',
          ],
          Science: [
            'science',
            'research',
            'study',
            'scientist',
            'discovery',
            'experiment',
          ],
          Environment: [
            'environment',
            'climate',
            'green',
            'sustainability',
            'carbon',
            'pollution',
          ],
          World: [
            'international',
            'global',
            'country',
            'nation',
            'world',
            'foreign',
          ],
          'Law & Crime': [
            'crime',
            'law',
            'legal',
            'court',
            'justice',
            'police',
          ],
        };

        const lowerText = text.toLowerCase();

        for (const [category, keywords] of Object.entries(categories)) {
          if (keywords.some((keyword) => lowerText.includes(keyword))) {
            return category;
          }
        }

        return 'General';
      }

      function generateTagsFromContent(text) {
        // Simple tag extraction - you could enhance this
        const commonWords = [
          'the',
          'and',
          'or',
          'but',
          'in',
          'on',
          'at',
          'to',
          'for',
          'of',
          'with',
          'by',
          'is',
          'are',
          'was',
          'were',
          'be',
          'been',
          'have',
          'has',
          'had',
          'do',
          'does',
          'did',
          'will',
          'would',
          'could',
          'should',
          'may',
          'might',
          'can',
          'must',
          'shall',
          'this',
          'that',
          'these',
          'those',
        ];

        const words = text
          .toLowerCase()
          .replace(/[^a-z\\s]/g, '')
          .split(/\\s+/)
          .filter((word) => word.length > 3 && !commonWords.includes(word));

        const wordCount = {};
        words.forEach((word) => {
          wordCount[word] = (wordCount[word] || 0) + 1;
        });

        const topWords = Object.entries(wordCount)
          .sort(([, a], [, b]) => b - a)
          .slice(0, 8)
          .map(([word]) => word);

        return topWords.join(', ');
      }

      function extractBiasAnalysis(reportContent) {
        // Extract bias analysis from report if available
        if (reportContent.includes('bias') || reportContent.includes('Bias')) {
          return 'Bias analysis completed during verification process. See verification report for details.';
        }
        return 'No specific bias analysis performed.';
      }

      function extractClaimMapping(reportContent) {
        // Extract claim-to-source mapping if available
        if (
          reportContent.includes('claim') ||
          reportContent.includes('Claim')
        ) {
          return 'Claim-to-source mapping completed during verification. See verification report for details.';
        }
        return 'Claims verified against provided sources during verification process.';
      }

      function extractSourceRatings(reportContent) {
        // Extract source ratings if available
        return 'Sources evaluated during AI verification process. See verification report for detailed analysis.';
      }

      // Event listeners for integration buttons
      document.addEventListener('DOMContentLoaded', function () {
        // Show integration section when verification is complete
        const originalStatusUpdate = statusText;

        // Override the status update to show integration when complete
        const observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            if (mutation.target.textContent === 'Verification Complete!') {
              setTimeout(showIntegrationSection, 500);
            }
          });
        });

        if (statusText) {
          observer.observe(statusText, { childList: true, subtree: true });
        }

        // Send to Article Creator button
        document.addEventListener('click', function (e) {
          if (e.target.id === 'send-to-creator-btn') {
            const verificationData = extractVerificationData();

            // Store data for transfer
            localStorage.setItem(
              'verification_output',
              JSON.stringify({
                data: verificationData,
                timestamp: new Date().toISOString(),
                source: 'ai_verification',
              })
            );

            // Navigate to create.html
            const createUrl = '../create.html?source=verification&auto=true';
            window.open(createUrl, '_blank');

            // Show success message
            const statusDiv = document.getElementById('integration-status');
            if (statusDiv) {
              statusDiv.innerHTML =
                '<span class="text-green-600">‚úÖ Verification data sent to Article Creator!</span>';
            }
          }

          if (e.target.id === 'copy-results-btn') {
            const verificationData = extractVerificationData();
            navigator.clipboard
              .writeText(JSON.stringify(verificationData, null, 2))
              .then(() => {
                const statusDiv = document.getElementById('integration-status');
                if (statusDiv) {
                  statusDiv.innerHTML =
                    '<span class="text-blue-600">üìã Verification data copied to clipboard!</span>';
                }
              });
          }
        });
      });
    </script>
  </body>
</html>
